Erlang
------
* designed for running production systems
* Recon is a module used for this


Robert Virding: Theoretical physicist originally

Installed Erlang R16B+

Why another language?
Ericsson best seller: AXE telephone switch; sucessful yet costly
-> timing constraints
-> at least 2 systems needed for fault tolerance
-> very large systems
-> everything (maintenance/upgrade etc) had to be done while the system was running. these systems never went down.
-> not just telecoms.

base erlang is functional language
Properties of Erlang: Declarative, Concurrent, Soft Real-time, Robustness, Distribution, Hot code loading, External interfaces
nonblocking!!! robust!!!
1500 lines -> prolog interpreter
to make it faster, the erlang developers made their own vm

elixir: semantically the same as erlang but slightly different syntactically and is built on top of erlang.
erlang in anger (good for devops)- written by person who works at Heroku

irc
******************************************

Erlang shell
____________
* terminate expression with full stop. without it, nothing happens. :)

help(). help
h(). history
b().
f(). - f(x).
forgets all variable bindins.

pwd().  -> print current dir
cd(Dir).
ls(). - ls(Dir).
q(). - quit
c(Module) - compile the file Module.erl
e(N). - evaluates the nth command in history
e(-1). evaulates previous commamnd
CTRL + (n, p, f, b, y, a, e....) move around just like emacs

Basic Erlang
--------------------------

* Data types
------------
 - based on expressions... you cannot have value.
 - every expression has a value that you can know but you cannot have value as an entity itself
 - no character data type in the language. we use integers for character representation.
 $a gives you the integer value of a i.e. 96
1. integers
2. floats (64 bit representation). follows IEEE 754 standard

you can do numerical calculations using Erlang but you shouldn't cause it wasn't designed for numerical calculations. Erlang's good at controlling other languages.

3. atom - constant literals; start iwth a lower case letter or are encapsulated by ''. any character code is allowed within an atom if using ''

4. booleans 
  1 == 2    true
  1 /= 2    true
  1 == 1.0   -> true (conversion 1 -> 1.0 happens)
  1 =:= 1    -> false (conversion doesn't happen)
  1 =/= 1.0  -> true (conversion doesn't happen)
  1 < 2      -> true
  a > z      -> false (lexical comparison)
  less < more ->  true 
  is_boolean(9+6)
  is_boolean(true)
  not((1<3) and (2==2))
  not((1<3) or (2==2))
  not((1<3) not (2==2))
  
  One thing that the developers didn't get right was equality ( i agree... my god... you have so many operators for equality that i will have to memorize them repeatedly... :(((( )
  we can do these equality tests between anything
  you can't create user defined datatypes. you can try to fake it... but at the low level, it's impossible.... so how do i make structures?
  There are 2 ways:
  i. tuples: { 123, bcd} - tuple of 2 elements. no restrictions on the types of the elements. can be of any type.
     {abc, {def, 123}, ghi} tuple of 3 elements ( second being a tuple itself)
	 {} - empty tuple
	 convention for structure definition - use a tuple whose first element is usually an atom determining what it is. e.g.
	 {person, 'Joe', 'Armstrong'}
	data is immutable. so {123, bcd} is immutable. if i wanted to add a third element, i would be creating a new tuple. cannot mutate anything.
  ii. lists: [1,2, 3,4,5,6,7,eight, nine] - dynamically sized,
  e.g. strings in erlang are lists of integer values.
  e.g. [a, [b, [c, d, e], f], g]
  e.g. [] empty list
  e.g. [january, february, march]
  e.g. [{person, 'joe', 'armstrong'}, {person, 'mike', 'williams'}, {person, 'robert', 'virding'}]
  
  the following 3 are exactly the same:
  [72, 101, 108, 108, 111]
  [$H, $e, $l, $l, $o]
  "Hello"
                        --------------- 
  {a, b, c} internally | 3 | a | b | c |
                        ---------------
 but lists are implemented using singly linked lists
  [a| ] -> [b| ] -> [c| ]
  lists allow new elements to be added/removed from the front. but you can't add/remove elements to the end or middle of the list as that would mean changing the pointer and in erlang everything's immutable. so you'd have to copy the node and update it while copying. you don't have to change existing nodes in any way while adding/removing from front. so operations at the front are fast and easy. Operations at the end or middle mean copying elements of the list. There is no copy function so you can't create private copies.
   |------------------|  
   |                  |
   V                  | 
  List = [Element | List] or  
         []
		 
  left side - head, right side - tail
* Variables 
* Complex Data Structures
* Pattern Matching

******************
******************

